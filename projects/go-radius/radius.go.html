<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/code/stayke.net/src/go-radius/radius.go.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="go">
<meta name="settings" content="dynamic_folds,no_pre,use_css,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="ir_black">
<style type="text/css">
<!--
body { color: #cecece; background-color: black; font-family: monospace; }
* { font-size: 1em; }
.Type { color: #FFFFB6; text-decoration: underline; }
.Statement { color: #6699CC; font-weight: bold; }
.Number { color: #FF73FD; }
.Conditional { color: #6699CC; }
.Keyword { color: #96CBFE; }
.FoldColumn { color: Cyan; background-color: Grey; padding-bottom: 1px; }
.Comment { color: #A8FF60; font-weight: bold; }
.String { color: #A8FF60; }
.FoldColumn { text-decoration: none; white-space: pre; }
.open-fold   .Folded      { display: none; }
.open-fold   .fulltext      { display: inline; }
.open-fold   .toggle-open   { display: none; }
.closed-fold .toggle-closed { display: inline; }

.closed-fold .fulltext      { display: none; }
.closed-fold .Folded      { display: inline; }
.closed-fold .toggle-open   { display: inline; }
.closed-fold .toggle-closed { display: none; }
-->
</style>

<script type='text/javascript'>
<!--

function toggleFold(objID)
{
  var fold;
  fold = document.getElementById(objID);
  if(fold.className == 'closed-fold')
  {
    fold.className = 'open-fold';
  }
  else if (fold.className == 'open-fold')
  {
    fold.className = 'closed-fold';
  }
}

-->
</script>
</head>
<body>
<div id='vimCodeElement'>
<span class="Statement">package</span>&nbsp;radius<br>
<br>
<span class="Statement">import</span>&nbsp;(<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="String">&quot;net&quot;</span><br>
)<br>
<br>
<span class="Keyword">const</span>&nbsp;(<br>
&nbsp;&nbsp;&nbsp;&nbsp;LocalAuth&nbsp;<span class="Type">string</span>&nbsp;=&nbsp;<span class="String">&quot;127.0.0.1:1812&quot;</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;LocalAcct&nbsp;<span class="Type">string</span>&nbsp;=&nbsp;<span class="String">&quot;127.0.0.1:1813&quot;</span><br>
)<br>
<br>
<span class="Keyword">type</span>&nbsp;Server&nbsp;<span class="Keyword">struct</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;&nbsp;&nbsp;&nbsp; *<span class="Type">chan</span>&nbsp;Packet<br>
&nbsp;&nbsp;&nbsp;&nbsp;secret&nbsp;<span class="Type">string</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;conn&nbsp;&nbsp; *net.UDPConn<br>
&nbsp;&nbsp;&nbsp;&nbsp;open&nbsp;&nbsp;&nbsp;<span class="Type">bool</span><br>
}<br>
<br>
<span class="Comment">// Sets up a Server starting it listening on the specified addr.</span><br>
<span class="Comment">// Pass a *chan Packet to have full control over how the Packets read</span><br>
<span class="Comment">// from the server are handled</span><br>
<span class="Keyword">func</span>&nbsp;Start(c *<span class="Type">chan</span>&nbsp;Packet, addr, secret&nbsp;<span class="Type">string</span>) (s *Server, err&nbsp;<span class="Type">error</span>) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;s = &amp;Server{c, secret,&nbsp;<span class="Keyword">nil</span>,&nbsp;<span class="Keyword">true</span>}<br>
&nbsp;&nbsp;&nbsp;&nbsp;err = s.listen(addr)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span><br>
}<br>
<br>
<span class="Comment">// Open a udp connection on addr, and loop input in a goroutine</span><br>
<span class="Keyword">func</span>&nbsp;(s *Server) listen(addr&nbsp;<span class="Type">string</span>)&nbsp;<span class="Type">error</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;udpAddr, err := net.ResolveUDPAddr(<span class="String">&quot;udp&quot;</span>, addr)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Conditional">if</span>&nbsp;err !=&nbsp;<span class="Keyword">nil</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;err<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;s.conn, err = net.ListenUDP(<span class="String">&quot;udp&quot;</span>, udpAddr)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Conditional">if</span>&nbsp;err !=&nbsp;<span class="Keyword">nil</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;err<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Comment">// loop reading</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">go</span>&nbsp;<span class="Type">func</span>() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">for</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buff :=&nbsp;<span class="Keyword">make</span>([]<span class="Type">byte</span>,&nbsp;<span class="Number">1024</span>)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n, addr, err := s.conn.ReadFromUDP(buff)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Conditional">if</span>&nbsp;(s.open) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*s.in &lt;- Packet{buff, n, addr, err}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="Conditional">else</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Keyword">close</span>(*s.in)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;<span class="Keyword">nil</span><br>
}<br>
<br>
<span class="Keyword">func</span>&nbsp;(s *Server) Close()&nbsp;<span class="Type">error</span>&nbsp;{<br>
&nbsp;&nbsp;&nbsp;&nbsp;s.open =&nbsp;<span class="Keyword">false</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;err := s.conn.Close()<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="Statement">return</span>&nbsp;err<br>
}<br>
</div>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
