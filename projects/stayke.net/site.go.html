<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>~/code/stayke.net/src/stayke.net/site.go.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="none">
<meta name="settings" content="dynamic_folds,no_pre,use_css,expand_tabs,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
body { color: #000000; background-color: #ffffff; font-family: monospace; }
* { font-size: 1em; }
.FoldColumn { color: #c00000; background-color: #c0c0c0; padding-bottom: 1px; }
.FoldColumn { text-decoration: none; white-space: pre; }
.open-fold   .Folded      { display: none; }
.open-fold   .fulltext      { display: inline; }
.open-fold   .toggle-open   { display: none; }
.closed-fold .toggle-closed { display: inline; }

.closed-fold .fulltext      { display: none; }
.closed-fold .Folded      { display: inline; }
.closed-fold .toggle-open   { display: inline; }
.closed-fold .toggle-closed { display: none; }
-->
</style>

<script type='text/javascript'>
<!--

function toggleFold(objID)
{
  var fold;
  fold = document.getElementById(objID);
  if(fold.className == 'closed-fold')
  {
    fold.className = 'open-fold';
  }
  else if (fold.className == 'open-fold')
  {
    fold.className = 'closed-fold';
  }
}

-->
</script>
</head>
<body>
<div id='vimCodeElement'>
package homepage<br>
<br>
import (<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;bytes&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;errors&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;fmt&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;github.com/paulbellamy/mango&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;io/ioutil&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;log&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;mime&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;net/http&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;os&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;path/filepath&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;strings&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&quot;time&quot;<br>
)<br>
<br>
var (<br>
&nbsp;&nbsp;&nbsp;&nbsp;html&nbsp;&nbsp;&nbsp;&nbsp; Pages<br>
&nbsp;&nbsp;&nbsp;&nbsp;projects Projects<br>
)<br>
<br>
type (<br>
&nbsp;&nbsp;&nbsp;&nbsp;Projects map[string][]string<br>
&nbsp;&nbsp;&nbsp;&nbsp;Pages&nbsp;&nbsp;&nbsp;&nbsp;map[string][]byte<br>
)<br>
<br>
var startTime time.Time<br>
var expireTime time.Time<br>
var headers mango.Headers<br>
<br>
func StartHTTP(addr string) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers = mango.Headers{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;MakeExpirationHeader()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;html = Pages{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;filepath.Walk(&quot;html&quot;, html.Walker)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;projects = Projects{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;filepath.Walk(&quot;projects&quot;, projects.Walker)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;projects.MakeNav()<br>
&nbsp;&nbsp;&nbsp;&nbsp;html.MakeNav()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;projects.CleanupFileLinks()<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;app := mango.Stack{}<br>
&nbsp;&nbsp;&nbsp;&nbsp;app.Address = addr<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;r := map[string]mango.App{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;^/resume(/)?(.html)?$&quot;: app.Compile(ResumeForward),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;^/project/.*&quot;: app.Compile(Project),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;^/code/.*&quot;:&nbsp;&nbsp;&nbsp;&nbsp;app.Compile(ProjectCode),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;^/.*&quot;:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; app.Compile(Index),<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;app.Middleware(mango.Routing(r))<br>
&nbsp;&nbsp;&nbsp;&nbsp;app.Run(FourOhFour)<br>
}<br>
<br>
func Index(e mango.Env) (mango.Status, mango.Headers, mango.Body) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if time.Now().After(expireTime) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MakeExpirationHeader()<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// urls with .html and without<br>
&nbsp;&nbsp;&nbsp;&nbsp;// handle / and /index<br>
&nbsp;&nbsp;&nbsp;&nbsp;f := e.Request().URL.Path<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if f == &quot;/&quot; || f == &quot;/home&quot; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = &quot;/index&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if strings.Index(f, &quot;.&quot;) &gt; -1 {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = &quot;html&quot; + f<br>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = &quot;html&quot; + f + &quot;.html&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;page, have := html[f]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if !have {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FourOhFour(e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers.Set(&quot;Content-Type&quot;, mime.TypeByExtension(f[strings.Index(f, &quot;.&quot;):]))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;req for %s&quot;, f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if t, err := time.Parse(http.TimeFormat, e.Request().Header.Get(&quot;If-Modified-Since&quot;)); err == nil &amp;&amp; t.Add(time.Second).Before(startTime) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 304, headers, &quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 200, headers, mango.Body(page)<br>
}<br>
<br>
func ResumeForward(e mango.Env) (mango.Status, mango.Headers, mango.Body) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;forwardHeaders := make(mango.Headers)<br>
&nbsp;&nbsp;&nbsp;&nbsp;forwardHeaders.Set(&quot;Location&quot;, &quot;<a href="https://angel.co/marins">https://angel.co/marins</a>&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 301, forwardHeaders, &quot;&quot;<br>
}<br>
<br>
func Project(e mango.Env) (mango.Status, mango.Headers, mango.Body) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;path := strings.Split(e.Request().URL.Path, &quot;/&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if len(path) &lt; 3 {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;invalid project request: %s&quot;, path)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FourOhFour(e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;var p, f string<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// accepts requests in the form project/file, project/, project<br>
&nbsp;&nbsp;&nbsp;&nbsp;// if no file send README.md.html<br>
&nbsp;&nbsp;&nbsp;&nbsp;p = path[2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;if len(path) == 3 {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = &quot;README.md.html&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;} else if f = path[3]; f == &quot;&quot; {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = &quot;README.md.html&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;projFiles, have := projects[p]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if !have {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;req for invalid project: %s&quot;, p)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FourOhFour(e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if t, err := time.Parse(http.TimeFormat, e.Request().Header.Get(&quot;If-Modified-Since&quot;)); err == nil &amp;&amp; t.Add(time.Second).Before(startTime) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 304, headers, &quot;&quot;<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;iframeUrl := fmt.Sprintf(&quot;/code/%s/%s&quot;, p, f)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;projectNav := make([]string, len(projFiles))<br>
&nbsp;&nbsp;&nbsp;&nbsp;for i, pfile := range projFiles {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;projectNav[i] = fmt.Sprintf(`&lt;a href=&quot;/project/%s/%s.html&quot;&gt;%s&lt;/a&gt;`, p, pfile, pfile)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;nav := strings.Join(projectNav, &quot;\n&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;codePage := html[&quot;html/codepage.html&quot;]<br>
&nbsp;&nbsp;&nbsp;&nbsp;codePage = bytes.Replace(codePage, []byte(&quot;{{{url}}}&quot;), []byte(iframeUrl), 1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;codePage = bytes.Replace(codePage, []byte(&quot;{{{filenav}}}&quot;), []byte(nav), 1)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;req for project file [%s]: %s&quot;, p, f)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers.Set(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 200, headers, mango.Body(codePage)<br>
}<br>
<br>
func ProjectCode(e mango.Env) (mango.Status, mango.Headers, mango.Body) {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;pathSpl := strings.Split(e.Request().URL.Path, &quot;/&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if len(pathSpl) != 4 {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;no file for /code req: %s&quot;, e.Request().URL.Path)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FourOhFour(e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;p := pathSpl[2]<br>
&nbsp;&nbsp;&nbsp;&nbsp;f := pathSpl[3]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;_, have := projects[p]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if !have {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;req for bad project: %s&quot;, p)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FourOhFour(e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;file, err := ioutil.ReadFile(fmt.Sprintf(&quot;projects/%s/%s&quot;, p, f))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;couldnt load /code file [%s]: %s&quot;, p, f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Print(err)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return FourOhFour(e)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;req for project code [%s]: %s&quot;, p, f)<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers.Set(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 200, headers, mango.Body(file)<br>
}<br>
<br>
func FourOhFour(e mango.Env) (mango.Status, mango.Headers, mango.Body) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;404 on: %s&quot;, e.Request().URL.Path)<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers.Set(&quot;Content-Type&quot;, &quot;text/html; charset=utf-8&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;return 404, headers, mango.Body(html[&quot;html/404.html&quot;])<br>
}<br>
<br>
func (p Projects) Walker(path string, info os.FileInfo, err error) error {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// TODO no subdirs<br>
&nbsp;&nbsp;&nbsp;&nbsp;if info.IsDir() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;level := strings.Count(path, &quot;/&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if level &lt;= 1 {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;adding project: %s&quot;, path)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return nil<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return filepath.SkipDir<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// skip the first dir (projects)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set second dir as the key (project name)<br>
&nbsp;&nbsp;&nbsp;&nbsp;// set the rest as the filepath<br>
&nbsp;&nbsp;&nbsp;&nbsp;spl := strings.SplitN(path, &quot;/&quot;, 3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;p[spl[1]] = append(p[spl[1]], spl[2])<br>
&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;added [%s] %s&quot;, spl[1], path)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return nil<br>
}<br>
<br>
func (p Projects) MakeNav() {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;var result []string<br>
&nbsp;&nbsp;&nbsp;&nbsp;for project, _ := range p {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = append(result, fmt.Sprintf(`&lt;a href=&quot;%s&quot;&gt;%s&lt;/a&gt;`, &quot;/project/&quot;+project, project))<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;html.Mustache(&quot;html/project.html&quot;, &quot;{{{projectnav}}}&quot;, strings.Join(result, &quot;\n&quot;))<br>
&nbsp;&nbsp;&nbsp;&nbsp;html.Mustache(&quot;html/codepage.html&quot;, &quot;{{{projectnav}}}&quot;, strings.Join(result, &quot;\n&quot;))<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;finished project nav&quot;)<br>
}<br>
<br>
// fix the file links and turn into links<br>
func (p Projects) CleanupFileLinks() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;for pr, fAr := range p {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i, f := range fAr {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p[pr][i] = strings.Replace(f, &quot;.html&quot;, &quot;&quot;, 1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
}<br>
<br>
func (ps Pages) Walker(path string, info os.FileInfo, err error) error {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// lame way to check if this is the root that was passed<br>
&nbsp;&nbsp;&nbsp;&nbsp;if info.IsDir() &amp;&amp; strings.Index(path, &quot;/&quot;) &gt; -1 {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return filepath.SkipDir<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;fileb, err := ioutil.ReadFile(path)<br>
&nbsp;&nbsp;&nbsp;&nbsp;if err != nil {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Print(err)<br>
&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ps[path] = fileb<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Print(&quot;cached: &quot; + path)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return nil<br>
}<br>
<br>
// replace out {{{}} for special pages<br>
func (ps Pages) Mustache(file, pattern, newdata string) error {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;page, have := ps[file]<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if !have {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;unable to mustache %s: no such file&quot;, file)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors.New(&quot;unable to mustache: no such file&quot;)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;newpage := bytes.Replace(page, []byte(pattern), []byte(newdata), 1)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ps[file] = newpage<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;if bytes.Equal(page, newpage) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.Printf(&quot;didnt replace %s in %s&quot;, pattern, file)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return errors.New(&quot;mustache didnt replace &quot; + pattern + &quot; in &quot; + file)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;return nil<br>
}<br>
<br>
func (ps Pages) MakeNav() {<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;navPages := []string{<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;home&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;about&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;project&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;resume&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;contact&quot;,<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;for i, l := range navPages {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;navPages[i] = fmt.Sprintf(`&lt;a href=&quot;/%s&quot;&gt;%s&lt;/a&gt;`, l, l)<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;nav := &quot;&lt;div id=\&quot;nav\&quot;&gt;\n&quot; + strings.Join(navPages, &quot;\n&quot;) + &quot;&lt;/div&gt;&quot;<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;// TODO check err here in case replace fails<br>
&nbsp;&nbsp;&nbsp;&nbsp;ps.Mustache(&quot;html/index.html&quot;, &quot;{{{nav}}}&quot;, nav)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ps.Mustache(&quot;html/about.html&quot;, &quot;{{{nav}}}&quot;, nav)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ps.Mustache(&quot;html/project.html&quot;, &quot;{{{nav}}}&quot;, nav)<br>
&nbsp;&nbsp;&nbsp;&nbsp;ps.Mustache(&quot;html/contact.html&quot;, &quot;{{{nav}}}&quot;, nav)<br>
}<br>
<br>
func MakeExpirationHeader() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;startTime = time.Now()<br>
&nbsp;&nbsp;&nbsp;&nbsp;expireTime = startTime.Add(24 * time.Hour)<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers.Set(&quot;Last-Modified&quot;, startTime.Format(http.TimeFormat))<br>
&nbsp;&nbsp;&nbsp;&nbsp;headers.Set(&quot;Expires&quot;, expireTime.Format(http.TimeFormat))<br>
}<br>
</div>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
